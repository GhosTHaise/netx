import { Project, SourceFile, FunctionDeclaration, VariableDeclaration, SyntaxKind, Type } from 'ts-morph';
import * as path from 'path';
import * as fs from 'fs/promises';

// --- Configuration (Pourrait être lu depuis un fichier ou args CLI) ---
const ACTIONS_DIR = path.resolve(process.cwd(), 'actions'); // Dossier des actions dans le projet UTILISATEUR
const OUTPUT_DIR = path.resolve(process.cwd(), 'node_modules', '.ma-super-lib-cache'); // Cache dans node_modules
const OUTPUT_TYPES_FILE = path.resolve(OUTPUT_DIR, 'index.d.ts');
const OUTPUT_RUNTIME_FILE = path.resolve(OUTPUT_DIR, 'runtime.js'); // Fichier JS pour l'import dynamique (simplifié)

interface ActionInfo {
  filePath: string; // Chemin relatif depuis ACTIONS_DIR
  functionName: string;
  // On pourrait ajouter ici les types des paramètres et du retour si l'analyse est plus poussée
}

async function findActionFiles(project: Project): Promise<SourceFile[]> {
  console.log(`Scanning for action files in: ${ACTIONS_DIR}`);
  try {
    await fs.access(ACTIONS_DIR); // Vérifier si le dossier existe
  } catch (error) {
    console.warn(`Actions directory not found: ${ACTIONS_DIR}. Skipping generation.`);
    return [];
  }
  // Ajoute tous les fichiers .ts/.tsx dans le dossier et sous-dossiers
  project.addSourceFilesAtPaths(`${ACTIONS_DIR}/**/*.action.ts`);
  project.addSourceFilesAtPaths(`${ACTIONS_DIR}/**/*.action.tsx`); // Si vous supportez TSX
  return project.getSourceFiles();
}

function extractExportedFunctions(sourceFile: SourceFile): ActionInfo[] {
  const actions: ActionInfo[] = [];
  const relativePath = path.relative(ACTIONS_DIR, sourceFile.getFilePath())
                         .replace(/\\/g, '/'); // Normaliser les chemins

  // Cherche les fonctions exportées (ex: export function myAction() {})
  sourceFile.getFunctions().forEach(func => {
    if (func.isExported()) {
      actions.push({
        filePath: relativePath,
        functionName: func.getName()!,
      });
    }
  });

  // Cherche les variables exportées qui sont des fonctions (ex: export const myAction = async () => {})
  sourceFile.getVariableDeclarations().forEach(decl => {
    if (decl.isExported()) {
      const initializer = decl.getInitializer();
      if (initializer && (initializer.getKind() === SyntaxKind.ArrowFunction || initializer.getKind() === SyntaxKind.FunctionExpression)) {
         actions.push({
            filePath: relativePath,
            functionName: decl.getName()!,
         });
      }
    }
  });


  return actions;
}

function generateTypeDefinition(actions: ActionInfo[]): string {
  let typeContent = `// Auto-generated by ma-super-lib\n`;
  typeContent += `/// <reference types="next" />\n\n`; // Pour les types Next si besoin
  typeContent += `import type { ${actions.map(a => a.functionName).join(', ')} } from '#actions';\n\n`; // Import symbolique
  typeContent += `declare module 'ma-super-lib/actions' {\n`;
  typeContent += `  interface ActionMap {\n`;

  // Regrouper par fichier pour une structure plus logique (facultatif)
  const groupedActions: { [key: string]: ActionInfo[] } = {};
  actions.forEach(action => {
      const key = action.filePath.replace(/\.action\.tsx?$/, '').replace(/\//g, '.'); // Crée une clé genre 'user.profile'
      if (!groupedActions[key]) {
          groupedActions[key] = [];
      }
      groupedActions[key].push(action);
  });


  for (const key in groupedActions) {
       typeContent += `    '${key}': {\n`;
       groupedActions[key].forEach(action => {
            // !! IMPORTANT !! Ici on met 'any' car extraire les vrais types est complexe.
            // Une version avancée analyserait func.getParameters() et func.getReturnType()
            // et essaierait de reconstruire la signature.
            typeContent += `      ${action.functionName}: (...args: any[]) => Promise<any>; // TODO: Replace any with actual types\n`;
       });
       typeContent += `    };\n`;
  }

  typeContent += `  }\n\n`;
  // Exporter une constante typée pour l'utilisation
  typeContent += `  export const actions: ActionMap;\n`;
  typeContent += `}\n\n`;

  // Définir un alias de chemin pour que l'import '#actions' fonctionne
  typeContent += `// Alias pour les imports réels (à configurer dans tsconfig.json du projet utilisateur)\n`;
  typeContent += `declare module '#actions' {\n`;
   actions.forEach(action => {
    // Chemin relatif depuis la racine du projet (supposée) vers le fichier d'action
    const importPath = path.relative(process.cwd(), path.join(ACTIONS_DIR, action.filePath))
                         .replace(/\\/g, '/').replace(/\.tsx?$/, '');
    typeContent += ` export { ${action.functionName} } from '${importPath}';\n`;
  });
  typeContent += `}`;


  return typeContent;
}


// Fonction pour générer un fichier JS qui peut être utilisé pour importer dynamiquement
// C'est une approche très SIMPLIFIÉE et probablement pas idéale pour le tree-shaking.
// Une meilleure approche utiliserait peut-être des imports dynamiques ou serait gérée
// par le bundler de l'utilisateur via les types et les imports normaux.
function generateRuntimeMapping(actions: ActionInfo[]): string {
    let runtimeContent = `// Auto-generated runtime mapping (simplified)\n`;
    runtimeContent += `const actionModules = {};\n\n`;

    actions.forEach(action => {
        // Chemin d'import relatif depuis ce fichier généré vers le fichier action
        const importPath = path.relative(OUTPUT_DIR, path.join(ACTIONS_DIR, action.filePath))
                           .replace(/\\/g, '/').replace(/\.tsx?$/, ''); // Chemin pour l'import JS
        runtimeContent += `actionModules['${action.filePath.replace(/\.action\.tsx?$/, '')}.${action.functionName}'] = `
                       + `() => import('${importPath}').then(mod => mod.${action.functionName});\n`;
    });

    runtimeContent += `\nexport default actionModules;\n`;
    return runtimeContent;
}


async function main() {
  const project = new Project({
    // Options de tsconfig si nécessaire, par défaut il cherche tsconfig.json
     compilerOptions: {
            // Important pour permettre de trouver les types même sans imports directs
            // Attention: peut ralentir les projets larges.
            // typeRoots: ["./node_modules/@types", "./actions"], // Indiquer où chercher des types globaux
            // baseUrl: ".", // Important pour la résolution des chemins relatifs
            // paths: { // Doit correspondre au tsconfig de l'utilisateur
            //    "@/*": ["./*"],
            //    "#actions": ["./actions"] // Alias pour les actions
            // }
        },
        // skipAddingFilesFromTsConfig: true, // Si on ne veut pas lire tsconfig.json

  });

  const sourceFiles = await findActionFiles(project);
  if (sourceFiles.length === 0) {
      console.log("No action files found.");
      // Créer un fichier de types vide pour éviter les erreurs d'import
      await fs.mkdir(OUTPUT_DIR, { recursive: true });
      await fs.writeFile(OUTPUT_TYPES_FILE, `// No actions found\n declare module 'ma-super-lib/actions' {\n export const actions: {}; \n}\n declare module '#actions' {} \n`);
      await fs.writeFile(OUTPUT_RUNTIME_FILE, `// No actions found\n export default {}; \n`);
      return;
  }


  const allActions: ActionInfo[] = [];
  sourceFiles.forEach(file => {
    console.log(`  - Processing: ${path.relative(process.cwd(), file.getFilePath())}`);
    allActions.push(...extractExportedFunctions(file));
  });

  if (allActions.length === 0) {
     console.log("No exported actions found in the files.");
      // Créer un fichier de types vide
      await fs.mkdir(OUTPUT_DIR, { recursive: true });
      await fs.writeFile(OUTPUT_TYPES_FILE, `// No exported actions found\n declare module 'ma-super-lib/actions' {\n export const actions: {}; \n}\n declare module '#actions' {} \n`);
      await fs.writeFile(OUTPUT_RUNTIME_FILE, `// No exported actions found\n export default {}; \n`);
      return;
  }


  console.log(`Found ${allActions.length} actions.`);

  const typeDefinition = generateTypeDefinition(allActions);
  // const runtimeMapping = generateRuntimeMapping(allActions); // Runtime simplifié (optionnel)

  // S'assurer que le dossier de sortie existe
  await fs.mkdir(OUTPUT_DIR, { recursive: true });

  // Écrire les fichiers générés
  await fs.writeFile(OUTPUT_TYPES_FILE, typeDefinition);
  console.log(`Generated type definitions at: ${OUTPUT_TYPES_FILE}`);

  // await fs.writeFile(OUTPUT_RUNTIME_FILE, runtimeMapping);
  // console.log(`Generated runtime mapping at: ${OUTPUT_RUNTIME_FILE}`);

  console.log("Generation complete.");
  console.warn("IMPORTANT: You might need to configure 'paths' in your tsconfig.json for '#actions' to resolve correctly:");
  console.warn(`
  {
    "compilerOptions": {
      "baseUrl": ".",
      "paths": {
        "#actions": ["./actions"] // Ou le chemin vers votre dossier d'actions
        // ... autres chemins
      }
    }
  }
  `);
   console.warn("Also, ensure your editor/IDE reloads TypeScript definitions.");

}

main().catch(err => {
  console.error("Error during action generation:", err);
  process.exit(1);
});